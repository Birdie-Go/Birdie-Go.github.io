---
layout:     post
title:      弥补深度学习和稀疏矩阵格式选择之间的差距
subtitle:   超级计算机原理 论文阅读
date:       2022/5/02
author:     Birdie
header-img: img/post_header.jpg
catalog: true
tags:
    - 并行计算
---

### 1 阅读文献：

[Yue Zhao](https://dblp.uni-trier.de/pid/48/76-11.html), [Jiajia Li](https://dblp.uni-trier.de/pid/89/9032.html), [Chunhua Liao](https://dblp.uni-trier.de/pid/44/6478.html), [Xipeng Shen](https://dblp.uni-trier.de/pid/36/4172.html):

**Bridging the gap between deep learning and sparse matrix format selection.**

[PPOPP 2018](#ZhaoLLS18): 94-108



### 2 相关背景

​		稀疏矩阵向量乘法(SpMV)是许多科学应用程序（如线性方程系统求解器）中最重要、最广泛使用的内核之一。这也常常是他们执行的性能瓶颈。由于具有不规则的间接数据访问模式，优化其性能是困难的。

​		关于SPMV性能的最重要的因素之一是选择适当的格式来表示内存中的稀疏矩阵。针对不同的应用场景和计算机架构提出了各种存储格式。不同的格式可能会严重影响数据的本地性、缓存性能，以及最终影响SpMV的端到端性能（。

​		这个问题是DNN，特别是卷积神经网络(CNN)的一个很好的候选问题，原因有几个原因。首先，选择正确的格式对程序员来说是一项具有挑战性的任务。稀疏矩阵的适当格式取决于其矩阵大小、非零分布、体系结构特性等。其次，传统的机器学习技术也难以解决。由于难以想出学习矩阵的正确特征，以及SpMV性能与稀疏矩阵的正确格式之间的复杂关系，到目前为止，传统的机器学习技术平均达到了85%和78%预测精度。考虑到预测错误可能会导致几倍的性能损失，需要一个更准确的预测模型。第三，与这个问题类似的其他问题，CNN已经被证明是有效的解决方案。特别是，它类似于图像分类——比如判断图像是否包含狗还是猫；在这两个问题中，正确的决定主要是由输入中元素的空间模式决定的。对于图像分类，模式是像素的，而对于稀疏矩阵格式的选择，它们是非零元素的。由于CNN在图像分类上显示出良好的有效性，这两个问题的相似性表明它对稀疏矩阵格式的选择有一定的前景。



### 3 问题描述

​		第一个问题是输入表示法。CNN通常要求所有输入数据具有相同的大小（因为它通常有固定数量的可见节点）。对于包含不同大小数据的数据集，通常使用一些数据归一化方法将它们转换为固定大小。对于图像，转换方式可以是裁剪、缩放或采样。这种方法通常适用于图像处理，因为它保留了图像中对象的主要模式。但是稀疏矩阵格式的选择对矩阵的一些微妙特征很敏感，这些特征可能会因为这些传统的变换而丢失。例如，缩放为非对角矩阵创建了一些对角线；由于对角线对SpMV的格式选择产生严重影响，缩放图像误导了CNN的学习和预测。因此，了解各种变换对保持稀疏矩阵的重要特征的影响，以及找到适合CNN对稀疏矩阵格式选择的需要的固定大小的表示，新的研究探索是必要的。

​		第二个问题是设计合适的CNN结构。CNN结构是指网络层数、每层网络类型、各层节点数。CNN结构的差异显著地影响了学习结果的质量。对于图像处理，研究人员和从业者对一些公共图像集使用了不同的CNN结构。然而，由于输入数据的不同表示，先前探索的图像处理结构可能不能有效地用于稀疏矩阵格式的选择。因此，需要新的研究来确定CNN的结构，以适应稀疏矩阵格式选择的需要。

​		第三个问题是稀疏矩阵格式选择的架构依赖性。正如之前的研究所表明的那样，机器的许多因素（如内存带宽、缓存大小、核数量）可能会影响SpMV在特定矩阵格式和给定矩阵的最佳格式上的性能。为一台机器建立的预测模型很少适合另一台机器。重新训练CNN是很耗时的。如何在系统中有效地迁移模型对于HPC问题是一个特别重要的问题。



### 4 现有解决方案

#### 4.1 稀疏矩阵存储格式

​		为了有效地存储和处理一个稀疏矩阵，压缩的数据结构。用于只存储非零的块。目前已经提出了各种存储格式。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/1.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1 稀疏矩阵存储格式及其相应的SpMV伪代码</div>
</center>



​		例如，图1显示了分别以COO、CSR、DIA格式表示的稀疏矩阵及其相应的SpMV算法。$m$、$n$和$nnzs$分别用于表示稀疏矩阵的行数、列数和非零项数。坐标(COO)格式显式地将行和列索引以及所有非零项的值分别存储在$rows$、$cols$和$data$数组中。压缩稀疏行(CSR)格式保留COO的相同$cols$和$data$数组，但将行索引压缩为$ptr$，其中的元素是$cols$/$data$中所有行的起始位置。对角线(DIA)格式沿对角线方向（从左上角到右下角）存储非零。在图1中的DIA示例中，第一行$data$包含矩阵A左下对角线上的两个元素，第二行用于矩阵A的主对角线，第三行用于矩阵右上角的对角线。数组偏移记录每个对角线与主对角线的偏移。

#### 4.2 卷积神经网络(CNN)

​		CNN是一类在发现输入中非线性模型的模式并进行数据分类的网络。图像识别中最常用的CNNs类型是卷积神经网络(CNNs)。

​		CNN通常由一组节点层组成。在图2(a)中，最左边的层是输入层，每个节点表示输入向量中的一个元素（例如，输入图像中的像素的灰色值），最右边的是输出层，每个节点表示输入属于两类之一的预测概率。

​		CNN的输出层给出了最终的预测，而其他层逐渐从输入中提取出关键特征。CNN可能由混合类型的层组成，一些用于子采样结果（池化层），另一些用于非线性变换。卷积层是最重要的，在这个过程中，卷积是将一个小窗口（称为滤波器）输入，在每个位置，它计算滤波器和滤波器覆盖的输入元素之间的点积，如图2(b)在二维情况中所示。在图2(a)中，连接三个输入节点与一层2节点的每三条边的权重形成了该级别的过滤器$<w_1, w_2, w_3>$。卷积层的结果称为激活图。在一个滤波层中可以使用多个滤波器，然后将产生多个激活贴图。最后一层（即输出层）通常与前一层有全连接。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/2.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2 CNN</div>
</center>

​		CNN训练过程的一部分是确定滤波器中参数的适当值（即网络边缘的权重）。在训练中，网络中的所有参数都用一些随机值初始化，通过从训练输入中学习进行迭代细化。每个训练输入都有一个标签。通过网络输入的正向传播给出了预测；它与标签的差异给出了预测误差。训练过程通过反向传播迭代地修改网络参数，使训练输入最小的整体误差。在使用CNN时，只需要前向传播来得到预测。

​		值得注意的是，CNN的输入大小通常是固定的，相当于其输入层中的节点数量。如果原始输入具有不同的大小，则必须将其标准化为统一的大小。



###  5 核心思想与创新点

​		文章的**核心思想**是：构建了一个基于CNN的稀疏矩阵格式选择器。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/3.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图3 概况</div>
</center>


​		如图3的左半部分所示，算法过程分为四个步骤。它假设已经有大量的稀疏矩阵$S$可以作为训练输入，以及一个目标计算平台$P$(SpMV的执行)。

​		（1）第一步是收集训练标签。它多次为$P$上的所有矩阵运行SpMV，每次都使用不同的矩阵格式。通过测量每个矩阵的执行时间，可以找到SpMV运行最快的格式，并用该格式的ID标记该矩阵。

​		（2）第二步将每个矩阵标准化为一个固定的大小，这样它们就可以被输入到CNN的输入层中。

​		（3）第三步设计了CNN的结构。所设计的CNN的参数被初始化为一些随机值。输出层由$K$个输出节点组成，每个节点对应于要选择的$K$个矩阵格式之一。

​		（4）第四步在收集的标签和归一化矩阵上运行标准CNN训练算法，最终确定CNN每个参数的值，并结束了构建过程。

​		对训练过的CNN模型进行推理很容易。对于一个给定的矩阵，它首先被归一化为CNN所要求的固定大小。然后归一化表示被输入入训练过的CNN，其输出节点给出每种格式的概率是输入矩阵使用的最佳选择。

​		步骤第一步和第四步很容易实现。步骤第二步和第三步面临着稀疏矩阵格式选择问题的一些特殊挑战。此外，由此产生的CNN是特定于培训平台$P$的，因为它使用了在$P$上收集的标签。如何快速将学习到的CNN迁移到另一个平台是另一个研究挑战。文章的**创新点**就是对描述中三个主要研究问题的解决方案。

#### 5.1 输入信息的表示形式

​		矩阵有各种大小。要让他们与CNN结合，他们必须按照CNN的输入层的需要，以单一的大小来表示。这个过程被称为矩阵归一化。重要的是，归一化要保持原始矩阵的特征，这对于确定矩阵使用的适当格式至关重要。

**来自传统方法的表示法** 在基于CNN的图像处理中，输入归一化是通过图像缩放，即对大图像进行下采样或插值。作者试图将同样的方法应用于矩阵。例如，在向下采样中，原始矩阵中的一个块映射到新矩阵中的一个元素。由于与SpMV性能相关的是非零元素的空间模式而不是它们的精确值，因此归一化矩阵的元素的值被设置为二进制值。如果原始块包含所有零，则将新元素设置为零，否则设置为1。它会得到一个二进制矩阵。

​		结果不令人满意，其构造的CNN的预测精度低。主要原因是，尽管缩放保留了图像中对象的粗粒度模式，但它丢失了一些对于矩阵格式选择至关重要的微妙信息。

​		图4显示了这样一个示例。原始矩阵包含不规则对角线，但在向下抽样后，归一化矩阵成为一个完美的正则对角矩阵。作为对角矩阵是矩阵格式选择的一个重要属性：一些矩阵存储格式(例如，DIA)是专门为有效地存储对角矩阵而设计的；因此，归一化结果对CNN结构和格式预测造成了混淆。这种情况经常发生在大的稀疏矩阵上。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/4.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图4 图像缩放丢失了矩阵的一些微妙但关键的信息</div>
</center>


​		作者探索了一些表示来帮助解决这些局限性。

**用密度表示法进行增强** 在密度表示中，它不是为原始矩阵的每个块产生0或1，而是产生一个在0到1之间的小数值，等于块中的非零块的数量除以块大小，如图5(a)如图4(a)中的原始矩阵所示。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/5.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图5 图4(a)中的矩阵的密度表示和直方图表示。</div>
</center>

​		与二进制表示相比，密度表示捕获了原始矩阵不同区域之间更详细的变化。二进制表示对于捕获原始矩阵中非零元素的整体空间模式仍然很有用。在一个CNN中使用这两个表示法，可能会充分利用这两个方法的优点。密度和二进制表示可以通过一次遍历原始矩阵来产生。

![A1]({{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/A1.png)

**距离直方表示** 作者的第二个建议是距离直方图或称为直方图表示，它通过直方图在矩阵中存储非零元素的空间分布。它由两个矩阵组成，一个存储原始矩阵的行的直方图，另一个存储列的直方图。直方图是基于一个元素与原始矩阵的主对角线之间的距离。

​		算法1概述了从给定矩阵构造行直方图的算法。作者以图4(a)中的原始矩阵为例进行解释。在这个例子中，作者为该矩阵构造一个4行直方图矩阵$R$。原始矩阵中的每连续两行都会在直方图矩阵中生成一行。假设直方图有4个关于元素到原始矩阵主对角线的距离。现在考虑图4(a)中的底部两行（从0开始编号）。第6行仅包含一个非零元素（值为$23$），其与主对角线的距离为$1$；该距离的直方图箱号为$\lfloor 1/2 \rfloor=0$。因此，R\[3][0]增加了$1$（算法1中的第9行和第10行）。第7行包含两个非零元素（值为$17$和$11$），它们与主对角线的距离分别为$4$和$1$。它们的直方图箱分别为$2$和$0$（由算法1中的第9行计算），R\[3][2]和R\[3][0]各增加$1$。因此，R的最后一行的结果是[2,0,1,0]。

​		同样，也可以为原始矩阵的列构造一个直方图。它们一起形成了矩阵的直方图表示。然后，通过将两个矩阵中的最大值除以每个矩阵中的值标准化为[0,1]的范围。

​		与二进制表示和密度表示相比，直方图——使用数值和利用距离，而不是直接的空间位置——倾向于捕获关于矩阵中非零元素分布的更丰富信息。同时，它们的尺寸调整起来更灵活。对于二进制和密度表示，由于矩阵在任何一维中都可以较大，因此这些表示通常是正方形以实现折衷。对于直方图，没有这样的需要；直方图的数量可能与行或列的数量不同。

#### 5.2 CNN的结构设计

​		CNN网络可以采用具有不同深度、宽度或类型的层的各种结构。不同的结构具有不同的建模优势和用途。例如，一个更复杂的网络和更深更宽的层通常可以捕获输入和输出之间更复杂的关系，但同时，它需要比更简单的网络需要更多的数据来训练。

**通用结构的不足** 在图像处理中，CNN的通常结构如图6所示。图像的不同通道中的值（例如像素的红、绿、蓝值）一起形成单个输入层，其他层都处理所有这些输入节点组合的值。图像处理的不同CNN之间的差异主要在于在输入层后的每个层的配置。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/6.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图6 传统的CNN结构，在网络的前期阶段整合了来自不同频道的信息。</div>
</center>

​		作者从一组类似于图像处理的结构类型的CNNs开始。然而，在训练了每个CNNs之后，作者发现，无论使用哪个输入表示，其预测精度都不令人满意。

​		通过对中间计算结果的检查，作者发现基本原因是在网络前期阶段来自不同来源的信息的组合。在图像处理中，不同的信息来源只是输入图像的不同通道，并且具有均匀的语义。例如，对于RGB图像，三个通道中的第$j$元素都对应于图像中的第$j$像素，这些值都是关于像素颜色的数值，只是使用不同的颜色通道。

​		然而，在作者的问题中，不同的信息来源并没有这种统一的语义以及一对一匹配的关系。考虑二进制表示和密度表示。即使每个元素都来自于原始矩阵中的一个区域，但它们也有不同类型的值。在直方图的情况下，即使两个直方图表示中的元素具有相同的值类型，它们也没有一对一的匹配关系：一个用于行，另一个用于列。因此，不同信息来源的组合不利于问题的解决。

**后期合并的结构** 为了解决这个问题，作者采用了另一种后期合并结构。如图7所示，该结构由两个独立的卷积网络组成，每个网络处理来自一个源的信息，只有在最后阶段，两个网络的输出作为联合特征组合在一起，输入到全连接层进行最终输出。这两个卷积网络可以看作是从两个输入信息源中提取关键特征的过程。最后一层结合了这些特征来进行最终的预测。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/7.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图7 进行后期合并的CNN结构。</div>
</center>


​		这种结构避免了在前期合并结构中不同来源的影响混合，并产生了两个好处。首先，它让问题更加简单。在前期合并的情况下，卷积网络必须同时考虑来自两种信息来源的影响，并提取出它们的组合特征。相比之下，后期合并结构中的每个卷积网络都只需要从一个信息来源中提取这些特征，减少了对训练数据和时间的需求。其次，分层结构避免了不同信息来源的不同值类型和语义中的复杂性。

​		无论是前期合并还是后期合并的结构，都有许多可能的CNN设计与不同数量的层和其他配置。作者通过训练和测试许多不同配置的CNNs来选择配置，并选择最好的配置。

#### 5.3 跨体系结构的自适应功能

​		与基于CNN的图像处理相比，跨架构迁移的需要是稀疏矩阵格式选择的另一个特殊方面。在图像处理中，数据标签与计算机无关：图片中的狗在任何机器上都是狗。但这不是稀疏矩阵格式的选择。标签是输入矩阵的最佳格式，不同的机器可能会有显著差异。因此，在一台机器上训练的CNN无法充分预测另一台机器的格式。

​		架构依赖意味着，必须在每台不同的机器上建立一个新的CNN，其中包括通过在新机器上的每个矩阵上重新运行SpMV来收集标签，并重新运行CNN训练算法来确定适当的参数。这两个部分都需要很多时间。在作者的实验中，对于大约9200个矩阵，这样的过程大约需要75个小时。


​		为了缓解这个问题，作者探索了迁移学习的使用。迁移学习是深度学习领域中的一种概念。在图像识别中，人们可以在大数据集上训练CNN，然后使用预先训练的网络作为训练CNN的新数据集的基础。

​		引入迁移学习的优点有两个。首先，作者将这个想法引入HPC来支持CNNs的跨架构可移植性，并指出了它在节省数据收集时间和CNN训练时间方面的好处。其次，作者证实了在这个背景下该想法是优秀的，并确定了合适的方法。


​		作者主要考虑了两种方法（这两个方法我也不知道该不该这么翻译）来实现稀疏矩阵格式选择的迁移学习思想。

**继续演化（Continuous evolvement）** 这种方法将现有的CNN视为新CNN的中间状态，在此基础上，它将新机器上收集的新训练数据提供给CNN，继续训练CNN直到收敛。该方法重用了之前的CNN的结构和参数。由于这些参数反映了输入矩阵的某些重要特征，重用它们可以为新数据集的CNN构造提供一个比随机值更好的起点。同时，即使两台机器上的标签可能会有所不同，但它们通常不会完全不同。通过继承前一个CNN的参数，新CNN的训练可以受益于这些参数在矩阵的特征和合适的格式之间已经捕捉到的某些关系。

**顶部演化（Top evolvement）** 这第二种方法继承了前一个CNN的所有部分，并保持结构和参数不变，除了顶部全连接层的参数。作者将CNN的重用部分的输出命名为CNN codes。由于重用，矩阵的CNN codes在整个机器上保持不变。因此，在新CNN的构建中，这种方法只是将这些CNN codes作为输入，输入到CNN的顶层，并使用标准反向传播（在新机器上收集的标签上）来学习这一顶层的合适参数。在这一层训练后，作者将这一层放在之前CNN重用的部分上，得到更新的CNN。顶部演化方法的基本原理是，CNN的主要部分可以被视为是输入的关键特征的提取。由于这两台机器上的任务具有相似的性质，因此输入的关键特征集也可能是相似的——所以可以重用。顶层将这些特性结合在一起，并对输出做出最终决定，因此与数据的标签密切相关，就可以进行更新。

**定性比较** 定性地说，顶部演化涉及到比继续演化小得多的参数变化。因此，它只需要更少的训练数据，这需要收集新标签所需的时间更短，CNN训练算法收敛的时间也更短。另一方面，继续演化允许更大的调整自由度；因此，从理论上讲，它能提供的最好的CNN（允许无限的训练数据），并不比顶级进化方法提供的更差。



### 6 验证实验

​		为了评估该方法的有效性，作者进行了一系列的实验，并将基于CNN的方法与现有的预测精度和最先进的方法进行了比较。此外，作者还展示了这三种输入表示的影响、后期合并的CNN结构的好处、两种迁移学习方法的影响，以及学习结果对输入表示粒度的敏感性。

#### 6.1 方法论

**比较基准** 稀疏矩阵格式预测的最新技术是李等人[1]和Sedaghati等人[2]提出的传统机器学习模型。他们手动想出了一组矩阵的特征，并基于一组训练矩阵的特征和标签建立了一个决策树。结果表明，决策树模型在预测精度和SpMV性能方面优于以往的方法。

**硬件** 作者为两个CPU系统和一个GPU平台构建了格式预测模型，详见表1。CNNs的训练都是在GPU上进行。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/T1.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">表1 在实验中使用的硬件平台。</div>
</center>
**要选择的软件平台和格式** 如图1所示，不同的格式要求对SpMV进行不同的编码。为了评估格式预测带来的SpMV的加速比，作者使用一个可以使用多种矩阵格式的SpMV库。一个SpMV库只包含一组过程，每个过程都使用一小组矩阵格式之一，它决定了实验中使用的格式集。

​		在CPU上，作者使用了两个SpMV库。其中一个是$Intel^®$MKL，它支持COO、CSR、DIA和其他几种格式。另一个是一个多功能的SpMV基准测试程序（在本文中称为SMATLib），它支持COO、CSR、DIA、ELL格式。这两个库都是多线程的，并且可以并行运行。

​		在$Intel^®$MKL上，作者对使用默认格式(CSR)的预测加速速度高达53.7×（平均1.46×）。作者将CPU结果讨论集中在SMATLib平台而不是MKL上，因为SMATLib被用于矩阵格式预测的最先进研究。重复使用它可以与之前的工作进行直接面对面的比较。该框架重复了性能测量50次。取平均值作为性能。作者在重复试验中观察到一些小的差异：与不同格式之间的显著性能差异相比，它们可以忽略不计。

​		在GPU上，作者使用了$NVIDIA^®$cuS-PARSE库，它支持COO、CSR、ELL、HYB和BSR格式。作者附加CUDA到cuS-PARSE实现，使它也与CSR5格式一起工作。

**数据集** 作者的实验使用了一套9200个矩阵(总大小约为400GB)的数据集。这些矩阵包括来自SuiteSparse矩阵集合的2757个real-world矩阵（我不太清楚这是什么矩阵），以及从它们中得到的一些exact矩阵（我也不知道这是什么矩阵）。作者对现有的矩阵做了一些变化，变化后不会太偏离real-world矩阵，仅仅使用了一些简单的启发式方法，如裁剪、转换和原始矩阵的随机组合。

**交叉校验** 作者通过5倍的交叉校验将测试数据从训练数据中分开。它需要20%的数据集来形成一个测试集，并使用其余的数据集进行训练。它重复这个过程5次，取出数据集的不同子集作为测试集。在所有的实验中，结果都是单精度的。作者对双精度的观察显示，与单精度上有相似的预测精度和加速比。

#### 6.2 预测精度

​		作者比较了CNN模型和之前的决策树(DT)模型的预测质量。作者使用了三个度量标准。第一个是整体的精度，定义为在矩阵总数上的正确预测的数量（即预测的最佳格式确实是最好的）。另外两种评估每种格式的预测质量：格式$X$的精度是所有预测$X$的正确分数；格式$X$的召回率是预测为$X$的$S_x$的比例，其中$S_x$是格式$X$确实是最好的矩阵集合。

​		表2显示了作者的三种基于CNN的模型（具有“二进制”、“二进制+密度”或“直方图”表示）和之前在$Intel^®$CPU平台上的基于决策树的模型(DT)的结果。“二进制”和“二进制+密度”使用128×128作为表示法的大小，而“直方图”使用128×50（这些尺寸是根据经验选择的）。表2中的第二列给出了来自整个9200个稀疏矩阵中的每个格式标签的矩阵数量。结果表明，所有三个CNN模型在几乎所有的指标上都优于DT模型。具有直方图的CNN取得了最佳的结果，总体准确率为93%；DT的准确率只有85%。CNN还为所有格式得到了更高的召回率和精度。

​		不同格式的结果也有所不同。有两个主要因素：训练数据的数量和模式的复杂性。例如，CSR有比其他格式有更好的预测结果，这是因为携带CSR标签的矩阵最多，这让CNN更充分地学习它。COO和ELL有相似的数据，但COO的预测结果比ELL差得多。作者的详细分析表明，支持ELL的矩阵倾向于有相似的模式（矩阵中的行有相似的非零数量），而COO并没有显示出清晰的模式。

​		表3报告了GPU平台上的测试结果。由于GPU内存有限，只有4218个矩阵可以在它上面运行。由于GPU cuSPARSE比SMATLib支持更多的格式，因此该表显示了六种格式的结果。在六种格式中，格式COO从未在GPU上获胜，而其他五种都在一些矩阵上获胜。总的来说，CNN在总体精度（90%对83%）和每格式指标方面都再次显著优于DT。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/T2.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">表2 Intel®CPU上的预测质量（底部小数显示整体精度）</div>
</center>

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/T3.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">表3 在GPU平台上的预测结果。</div>
</center>

#### 6.3 加速比

​		图8显示了测试矩阵上的加速比分布，给出了这两种模型最佳格式的不同预测。加速比为1的水平线明确地分离了使用CNN模型实现加速的矩阵和DT模型没有显示加速的矩阵。CNN模型相比DT模型，在86%矩阵上SPMV性能得到了提高。使用CNN模型预测格式的SpMV比DT模型平均加速1.73×，最大加速5.2×。这个结果进一步证实了稀疏格式对SPMV的性能至关重要。此外，作者还用CNN模型测试了默认CSR格式的SpMV加速，平均为2.23×，最大为14.9×。对于GPU平台，CNN模型平均达到1.7×，默认CSR格式最大加速22.5×。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/8.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图8 CNN对基于DT的预测的加速比。</div>
</center>

#### 6.4 模型迁移

​		图9展示了这两种迁移学习方法的效果。这些方法将在$Intel^®$平台上训练过的CNN模型迁移到$AMD^®$平台上。两个方法的好处是很明显的。在较少的训练数据上，它们可以比“从头开始”的方法获得更好的精度。请注意，迁移模型的时间包括CNN模型的再训练时间以及在新平台上收集标签的时间。后者需要花费大部分时间。在作者的实验中，收集9200个矩阵的标签大约需要75个小时，因为它需要在每个矩阵上多次执行SpMV。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/9.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图9 在新平台（AMD®平台）上的不同再训练方法的预测准确性。（x=0处的精度无需再训练。）</div>
</center>

​		因此，迁移学习方法大幅减少所需的再训练数据，大大缩短了模型迁移过程。假设在新平台上获得一个精度为90%的模型。从图9可以看出，对于“顶部演化”，只需要“从头开始”方法的四分之一时间，而“继续演化”方法则是三分之二时间。总体上，重新学习4000个输入后，“继续演化”的精度略高于“顶部演化”，而“顶部演化”提供了更快的学习过程。

#### 6.5 CNN结构的影响

​		作者比较了后期合并和前期合并（图6和图7）。图10显示了分层结构的CNN。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/10.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图10 CNN后期合并结构（括号中的是图层形状）。</div>
</center>

​		图11显示了两种CNN模型的损耗函数曲线。在这里，损失函数被定义为真实标签和预测标签之间的交叉熵。交叉熵是衡量分布之间相似性的一种度量：它越小，这两个分布就越近。后期合并结构的损失函数比前期合并结构的损失快得多。后期合并结构使用约7000步后收敛到0.1左右的损失值，而前期合并结构在10000步后收敛到0.4。通过仅使用1000个时间步长，后期合并的损失函数值为前期合并的一半。此外，后期合并结构的行为比前期合并结构更稳定。这些结果证实了不同信息来源的后期混合简化了预测问题，避免了由于混合产生的负面影响。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="{{site.url}}/img/2022-5-02-弥补深度学习和稀疏矩阵格式选择之间的差距/11.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图11 两种不同结构设计的损失函数收敛性的比较。</div>
</center>


### 7 启发

​		最开始的时候，我选择这篇文章阅读还是有原因的。一是我对CNN和稀疏矩阵各自都有一定程度的了解。之前在计算机组成原理课程中，用汇编语言实现了一个CNN中简单的卷积核，而在实验室中，我的导师也做了一些跟深度学习有关的研究，我也复现过简单的CNN网络。因此，对CNN还是具有一定程度的了解的。而对于稀疏矩阵，我的第一次了解是在matlab课中，用于存储一些比较大的矩阵。阅读文献如果有大量的陌生概念，是很难去理解的。而有了一些前置知识后，对理解会有一个很大的帮助。因此，这是我选择这篇文章的原因之一。而另一个原因则是，我很好奇这两者是如何联系在一起的，这也算是对思路的一点小小的拓展吧。

​		用神经网络加速稀疏矩阵向量乘法来加速运算一些问题，也是一个比较特别的方向。在此之前我没有了解过关于SpMV有关的知识，因此在我的认知中，很多时候加速一个复杂度很高的算法，要么采用并行计算或者用性能更好的计算器加速运算，或者就是改变算法，让降低算法的复杂度。因为矩阵乘法在我的印象中是一个固定复杂度的算法，很难有什么质的提升。也正是因为这样，我也没有考虑过通过加速矩阵乘法来实现复杂度的降低。这对我来说是一个启示。有些在我们认知中根深蒂固的算法，可能由于输入数据的一些特殊的性质（比如稀疏矩阵相对于普通矩阵就是一个很特别的存在），使得可以采用全新的计算方式来计算。

​		实验中考虑的要素还是挺多的，我最开始认为，CNN和稀疏矩阵的结合，考虑的要素仅仅是SpMV的加速比以及准确度。但作者考虑的东西明显比我要多得多：这三种输入表示的影响、后期合并的CNN结构的好处、两种迁移学习方法的影响，以及学习结果对输入表示粒度的敏感性。尤其是平台之间的模型迁移，这点我是没想到的。就像我们平时复现代码的时候，很容易地就直接套用已经开源的代码和模型，从来没有考虑过，训练好的模型在不同的平台上可能会有差异。正是由于这种差异，让作者思考了更多的东西，比如后期合并、迁移学习等等。这对我也是一个启发，它让我意识到，考虑问题在不同背景下的不同特点，可能会看到更多的东西，也许能发现更多有意思的问题。



### 8 引用

（在此仅列出对说明文章有必要的引用）

[1] Jiajia Li, Guangming Tan, Mingyu Chen, and Ninghui Sun. 2013. SMAT: An Input Adaptive Auto-tuner for Sparse Matrix-vector Multiplication. In *Proceedings of the 34th ACM SIGPLAN Conference on Programming* *Language Design and Implementation (PLDI ’13)*. ACM, New York, NY, USA, 117–126. https://doi.org/10.1145/2491956.2462181

[2] Naser Sedaghati, Te Mu, Louis-Noel Pouchet, Srinivasan Parthasarathy, and P. Sadayappan. 2015. Automatic Selection of Sparse Matrix Rep resentation on GPUs. In *Proceedings of the 29th ACM on International* *Conference on Supercomputing (ICS ’15)*. ACM, New York, NY, USA, 99–108. https://doi.org/10.1145/2751205.2751244