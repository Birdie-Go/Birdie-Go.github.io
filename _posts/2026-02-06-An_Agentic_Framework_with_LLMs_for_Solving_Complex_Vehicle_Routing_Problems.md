---
layout:     post
title:      An Agentic Framework with LLMs for Solving Complex Vehicle Routing Problems
subtitle:   LLM agent CO
date:       2026/02/06
author:     Birdie
header-img: img/post\_header.jpg
catalog: true
tags:
    - 论文阅读
    - 组合优化
    - ICLR
---

An Agentic Framework with LLMs for Solving Complex Vehicle Routing Problems

Ni Zhang, Zhiguang Cao, Jianan Zhou, Cong Zhang, and Yew-Soon Ong

ICLR2026，rating：4664

https://openreview.net/forum?id=BMOgYw4EhQ



### 引入

LLM在CO中，第一个方向侧重于为传统VRP演化基本启发式算法，代表性例子包括EoH和ReEvo。相比之下，第二个方向强调开发能够处理多种VRP变体的通用框架，使其更加实用和可扩展。

第二个方向中，尽管ARS和DRoC都能处理复杂的VRP，但这些模块级生成方法**不具备自包含性**，在框架设计阶段依赖于手工编写的代码模块或外部求解器，并且**不是完全自动化的**，因为在框架执行阶段它们仍然需要人工参与来提取实例特定的信息。

![image-20260206145646649]({{site.url}}/img/2026-02-06-An_Agentic_Framework_with_LLMs_for_Solving_Complex_Vehicle_Routing_Problems/image-20260206145646649.png)

我们引入了一个**基于LLM的智能体框架（Agentic Framework with LLMs, AFL）**，用于端到端解决复杂VRP，从问题实例到解决方案。具体来说，它直接从实例输入中提取领域知识，并利用这些知识指导代码生成。为了增强在复杂约束下生成代码和所得VRP解决方案的可行性和可靠性，该流程被分解为三个易于处理的子任务：**问题描述**、**代码生成**和**解决方案推导**，每个子任务由多个针对其任务定制的LLM智能体处理。总共，我们设计了**四个专门的智能体**，包括**生成智能体（Generation Agent, GA）**、**判断智能体（Judgment Agent, JA）**、**修订智能体（Revision Agent, RA）**和**错误分析智能体（Error Analysis Agent, EAA）**，它们协作以确保跨功能一致性、逻辑合理性和约束满足。我们的主要贡献总结如下：

1. **概念上**，我们将LLM定位为解决复杂VRP的自包含框架的知识渊博开发者，实现从问题实例到解决方案的完全自动化，而不依赖于手工编写的模块或外部求解器。
2. **方法论上**，我们提出了AFL，一个智能体LLM框架，将本质上难以处理的全流程分解为三个易于管理的子任务，并采用四个专门智能体协作增强代码和解决方案的可信赖性。
3. **实验上**，我们在**60个VRP**上评估AFL，包括来自文献的48个代表性VRP、来自实际场景的8个复杂电动VRP，以及4个更广泛设置中的经典VRP。大量结果证明了我们框架的有效性和通用性，显示出与精心定制算法相媲美的性能，同时在代码可靠性和解决方案可行性方面显著优于现有的基于LLM的基线方法。



### 方法

![image-20260206145743227]({{site.url}}/img/2026-02-06-An_Agentic_Framework_with_LLMs_for_Solving_Complex_Vehicle_Routing_Problems/image-20260206145743227.png)

在本节中，我们介绍AFL，一种用于解决复杂VRP的智能体LLM框架，通过将流程结构化为三个子任务：**问题描述**、**代码生成**和**解决方案推导**。在这些子任务中，专门化的智能体，包括**生成智能体（GA）**、**判断智能体（JA）**、**修订智能体（RA）**和**错误分析智能体（EAA）**，协作完成各自的角色，最终增强生成代码和所得解决方案在特定问题实例约束下的可信赖性。

AFL的概述呈现在图1中。具体来说，给定一个VRP实例 $\mathcal{G}$，系统首先通过GA、JA和RA的协作操作生成问题描述 $\mathcal{D}(\mathcal{G})$。然后使用该问题描述查询存储先前测试过的问题代码的缓冲区，检查是否已存储相关代码。如果存在此类代码，工作流程直接进入解决方案推导阶段。否则，GA逐步逐个生成所需函数，同时JA和RA迭代评估和优化代码，直到满足所有要求和约束。一旦产生完整的实现，就执行它以推导解决方案。如果发生执行错误，EAA诊断其原因并提供解释和建议，RA和JA使用这些信息来修订代码。这一迭代过程持续进行，直到代码通过验证并产生可行的解决方案。最后，相应的问题描述和代码存储在缓冲区中供将来重用。每个子任务的智能体提示和输出示例在附录D中提供。下面，我们详细介绍每个专门智能体和流程阶段。

### 专门智能体

**生成智能体（GA）**负责生成描述和代码。在问题描述子任务中，它们为输入的VRPLib格式实例 $\mathcal{G}$ 生成描述 $\mathcal{D}(\mathcal{G})$。在代码生成子任务中，它们在实例、生成的描述和与函数 $f$ 相关的特定提示 $\mathcal{P}(f)$ 的指导下，以端到端方式生成功能代码 $\mathcal{C}(\mathcal{G}, \mathcal{D}(\mathcal{G}), \mathcal{P}(f))$。生成的描述和代码随后被转发给JA进行评估。

**判断智能体（JA）**评估生成的描述和代码的有效性。在问题描述子任务中，它们验证 $\mathcal{D}(\mathcal{G})$ 是否与实例上下文一致。在代码生成和解决方案推导子任务中，它们进一步评估生成或修订的代码是否满足提示要求，并且没有语法和逻辑错误。如果判断为正面，则接受描述或代码，流程进入下一步。否则，JA提供已识别问题的解释以及RA解决问题的建议。

**修订智能体（RA）**优化描述和代码。描述修订在JA的反馈和实例上下文的指导下进行，而代码修订还额外利用先前生成的描述。每次修订后，更新的描述或代码返回给JA进行重新评估，这一过程持续进行，直到达到正面判断。

**错误分析智能体（EAA）**仅在解决方案推导子任务中运行，在此它们分析代码执行期间错误的原因，并提供解决建议。然后将分析传递给RA进行代码修订。

### 子任务1：问题描述

**描述生成。** 给定一个VRPLib格式实例 $\mathcal{G}$，我们的框架自动从实例上下文中提取领域知识，无需人工干预，为问题设置提供用户友好的界面。VRPLib格式是VRP中广泛采用的基准规范，定义了基本元素，如问题类型、节点数量、节点坐标、仓库ID和各种约束相关参数，如表2所总结。基于此，GA为给定实例生成问题描述 $\mathcal{D}(\mathcal{G}) = \lbrace P, S, K, X, Y, Z\rbrace$。详细示例在附录D.1中提供。这里，我们将 $\mathcal{D}(\mathcal{G})$ 的组成部分定义如下：

1) $P$ 指定问题类型（例如，CVRP、VRPTW、ECVRPTW）。它从实例上下文中定义的问题类型和约束相关参数推断得出，并决定生成的代码文件名（例如，CVRP.py）。

2) $S$ 表示实例问题类型的文本描述。它提供给代码生成子任务，以告知智能体问题定义。

3) $K$ 表示约束集合及其解释。这些从实例上下文中指定的约束相关参数和问题类型推导得出。此外，$K$ 包括访问约束和仓库约束，这些是GA自动分析和推断的补充要求。在代码生成子任务中，$K$ 指导智能体将这些约束嵌入到功能设计中，从而增强解决方案的可行性。

4) $X$ 表示解决给定实例所需的输入。在代码生成子任务中，它指定必须从实例中读取的信息，并通过要求输入变量名与 $X$ 中的变量名匹配来强制执行一致性，从而减少潜在错误。例如，在CVRP中，$X$ 包括节点坐标、仓库ID、客户需求和车辆容量。

5) $Y$ 指预期输出。例如，在CVRP中，求解器应产生一组车辆路径，每条路径从仓库开始和结束，恰好访问每个客户一次，确保没有车辆路径超过容量，并满足所有需求。此外，返回的路径应是候选解中的最佳可行解决方案。

6) $Z$ 表示目标函数，例如最小化总行驶距离，进一步用于构建成本函数代码。

**描述判断与修订。** 在GA生成上述问题描述 $\mathcal{D}(\mathcal{G})$ 后，JA评估其正确性。评估检查：(i) $\mathcal{D}(\mathcal{G})$ 的任何组成部分是否与实例冲突，(ii) 组成部分是否内部一致，以及 (iii) 输入定义 $X$ 是否在实例上下文中正确指定。如果检测到冲突，实例上下文作为参考标准。如果没有发现问题，则输出设置为TRUE，问题描述子任务终止，流程进入下一个代码生成子任务。否则，输出设置为FALSE，伴随负面判断的解释和RA进行更正的建议。然后RA基于JA的反馈和实例上下文修订 $\mathcal{D}(\mathcal{G})$。修订后的描述返回给JA进行重新评估，这一迭代过程持续进行，直到JA确认 $\mathcal{D}(\mathcal{G})$ 正确。这一迭代程序提高了 $\mathcal{D}(\mathcal{G})$ 的准确性，如第4.5节的消融研究所示。问题描述子任务为代码生成提供基本信息，并强制执行统一的命名约定和约束，这些必须在整个流程中保持一致。

### 子任务2：代码生成

我们采用统一的**破坏-插入启发式（destroy-insert heuristic）**来解决VRP，因为它比其他方法提供更大的灵活性，能够处理复杂的实际变体。代码生成子任务由相互依赖的函数组成：`read_vrp`、`distance`、`cost`、`initial`、`destroy`、`insert`、`validate`和`main`，它们共同形成一个完整的VRP求解器。然而，生成完整的求解器代码具有挑战性，因为它需要在满足所有要求的同时保持多个函数之间的一致性。为解决此问题，GA顺序生成函数，每个函数都基于先前生成的代码构建，以确保正确性并减轻LLM的负担。此外，JA和RA在每个函数生成后迭代优化代码，纠正未满足的要求、语法错误和逻辑不一致。我们在下面详细描述每个步骤。

**代码生成。** 问题解决工作流程的代码结构如图2所示。我们指定每个函数的角色，为引导GA生成相应代码提供结构化基础。注意，这些函数仅在解决方案推导子任务中执行，如果出现运行时错误，则由EAA修复。首先，`read_vrp`将VRPLib格式实例文件解析为结构化字典，包含输入 $\overline{X} \in \mathcal{D}(\mathcal{G})$ 中指定的所有必需字段，确保 $X$ 中的每个变量都从实例上下文 $\mathcal{G}$ 中准确提取。接下来，`distance`从节点坐标计算距离矩阵。`initial`使用尊重 $K$ 中约束的贪婪策略构建解决方案。解决方案的可行性由`validate`验证。`cost`根据目标函数 $Z$ 评估给定解决方案的目标值。为实现迭代改进，`destroy`遵循附录C.2和算法1中描述的策略，从当前解决方案中移除一部分客户。

然后，`insert`函数将移除的客户重新插入到可行位置，同时最小化额外成本。如果没有可行的插入位置，则分配新车辆来服务这些客户，同时遵守 $K$ 中的约束。在每个改进步骤中，所得解决方案的可行性由`validate`验证，以确保满足 $K$ 中的每个约束。如果发生约束违反，函数必须引发错误，从而帮助EAA进行调试。最后，`main`编排整个工作流程，包括初始化、迭代改进和整体解决方案管理，如图2所示。在初始化阶段，生成初始可行解决方案；在改进阶段（总共 $T$ 步），通过破坏、插入、验证和成本评估迭代优化解决方案，新解决方案根据模拟退火准则接受（见附录C.3）。

**代码判断与修订。** 对于GA生成的每个函数，JA评估迄今为止生成的代码的正确性，检查是否符合要求，并检测任何语法或逻辑错误。如果识别出问题，RA基于JA的反馈和实例上下文修订代码。修订后的代码返回给JA进行重新评估，这一过程重复进行，直到JA给出正面判断。通过在生成下一个函数之前验证和纠正每个代码段，这种机制减轻了后续代码生成和修订的负担，提高了效率，并增强了最终求解器实现的可靠性。此外，约束考虑在整个代码生成过程中强制执行。生成的代码被反复检查，以确保 $K$ 中的所有约束都被正确纳入。这种迭代执行有助于最终求解器产生相对于实例约束可行的解决方案。

### 子任务3：解决方案推导

代码生成子任务中产生的函数并不总是可执行的，因为构建完整的VRP求解器高度复杂。错误可能由多种原因引起：有些源于语法错误，有些源于逻辑缺陷，还有一些源于未满足的要求，例如未能纳入某些约束。尽管我们设计了在代码生成期间强制执行约束考虑等策略，但保证LLM生成代码的正确性仍然非易事。为应对这一挑战并增强生成的VRP求解器的可信赖性，我们利用EAA来识别错误的原因，并提供纠正解释和建议。与代码生成子任务类似，RA随后基于这些反馈修改代码，之后JA评估修订。如果代码仍然不满意，RA根据JA的反馈进一步调整，这一过程重复进行，直到JA给出正面判断。然后重新执行修订后的代码以获得可行解决方案。最终，模型将问题描述 $\mathcal{D}(\mathcal{G})$ 连同相应的生成代码存储在缓冲区中。如果再次遇到相同的问题，框架可以直接重用存储的代码，从而提高效率并避免冗余计算。

### 实验

![image-20260206145812574]({{site.url}}/img/2026-02-06-An_Agentic_Framework_with_LLMs_for_Solving_Complex_Vehicle_Routing_Problems/image-20260206145812574.png)

![image-20260206145824912]({{site.url}}/img/2026-02-06-An_Agentic_Framework_with_LLMs_for_Solving_Complex_Vehicle_Routing_Problems/image-20260206145824912.png)

![image-20260206145910347]({{site.url}}/img/2026-02-06-An_Agentic_Framework_with_LLMs_for_Solving_Complex_Vehicle_Routing_Problems/image-20260206145910347.png)



